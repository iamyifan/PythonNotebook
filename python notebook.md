# Python 编程语言专项练习

1. Python 变量的查找顺序为：

   ```
   【A】局部作用域>外部嵌套作用域>全局作用域>内置模块作用域
   【B】外部嵌套作用域>局部作用域>全局作用域>内置模块作用域
   【C】内置模块作用域>局部作用域>外部嵌套作用域>全局作用域
   【D】置模块作用域>外部嵌套作用域>局部作用域>全局作用域
   ```

   正确答案：D
   
   ```
   Python 中的四种作用域查找顺序——LEGB原则
   L（Local），即局部作用域，例如在函数中定义的变量；
   E（Enclosing），即外部嵌套作用域，例如上级函数的局部作用域；
   G（Global），即全局作用域，例如模块级别的变量；
   B（Built-in），即内置模块作用域，例如int和print。
   ```

2. 对于 Python 中 `__new__` 和 `__init__` 的区别，下列说法正确的是：

   ```
   【A】__new__是一个静态方法，而__init__是一个实例方法
   【B】__new__方法会返回一个创建的实例，而__init__什么都不返回
   【C】只有在__new__返回一个cls的实例时，后面的__init__才能被调用
   【D】当创建一个新实例时调用__new__，初始化一个实例时用__init__
   ```

   正确答案：A、B、C、D

   ```
   __new__ 为构造函数，属于静态方法。在实例创建之前被调用，在创建实例后返回该实例。
   __init__ 为初始化方法，属于非静态方法。在 __new__ 实例创建之后被调用，对实例进行初始化。
   
   静态方法属于类所有，只能访问类中的静态变量和其他静态方法，静态方法在类实例化前就可以使用。
   非静态方法可以访问类中的任何成员，非静态变量必须在实例化之后才能分配内存。
   静态方法和静态变量在创建后始终占用同一个内存空间，而不同的实例则会占用多个内存空间。
   静态方法效率较高，但不能自动销毁；非静态方法效率较低，可以自行销毁。
   ```

3. 执行以下程序，结果输出为：

   ```python
   a = [1]
   b = 2
   c = 1
   
   def fn(lis, obj):
       lis.append(b)
   	obj = obj + 1
       return lis, obj
   
   fn(a, c)
   print(fn(a, c))
   ```

   ```
   【A】 ([1, 2, 2], 2)
   【B】([1, 2, 2], 3)
   【C】([1, 2], 2)
   【D】([1, 2], 3)
   ```

   正确答案：A

   ```
   当函数参数为可变对象时，采用引用传递。函数中对变量的修改会对实参造成影响；
   当函数参数为不可变对象时，采用值传递。函数中对变量的修改不会影响到实参。
   
   Python 中的不可变对象：元组、字符串、数值
   Python 中的可变对象：列表、字典、集合
   
   参考：https://www.jb51.net/article/223840.htm
   ```

4. 执行下列程序，输出结果为：

   ```python
   def fn():
     t = []
     i = 0
     while i < 2:
       t.append(lambda x: print(i*x,end=","))
   	i += 1
       return t
   
   for f in fn():
       f(2)
   ```

   ```
   【A】4,4,
   【B】2,2,
   【C】0,1,
   【D】0,2,
   ```

   正确答案：A

   ```
   ```

   